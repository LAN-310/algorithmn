动态规划
===
动态规划核心的思想就是将每个问题中的当前步状态都看作与前一步或前几步的状态相关，最最主要且困难的就是分析出他们之间的关系并写出状态转移方程。

1、思考状态（重点）

状态的定义，先尝试「题目问什么，就把什么设置为状态」；

然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」。

「状态转移方程」是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到。

2、思考状态转移方程（核心、难点）

状态转移方程是非常重要的，是动态规划的核心，也是难点；

常见的推导技巧是：分类讨论。即：对状态空间进行分类；

归纳「状态转移方程」是一个很灵活的事情，通常是具体问题具体分析；

除了掌握经典的动态规划问题以外，还需要多做题；

如果是针对面试，请自行把握难度。掌握常见问题的动态规划解法，理解动态规划解决问题，是从一个小规模问题出发，逐步得到大问题的解，并记录中间过程；

「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。

3、思考初始化

初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。

角度 1：直接从状态的语义出发；

角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；

角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。

4、思考输出

有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。

5、思考优化空间（也可以叫做表格复用）

「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；
「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；
非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。

转载于：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/

leetcode5 最长回文子串
---

将当前回文串s的状态从i到j是否为回文子串dp[i][j]与dp[i+1][j-1]联系起来，如果s[i]=s[j],则dp[i][j]与dp[i+1][j-1]的状态是相同的，否则dp[i][j]为false

leetcode72 编辑距离
----

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符

删除一个字符

替换一个字符

这个题目困难的地方在于将操作与状态转移联系起来

对单词 A 删除一个字符和对单词 B 插入一个字符是等价的

我们用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。

当我们获得 D[i][j-1]，D[i-1][j] 和 D[i-1][j-1] 的值之后就可以计算出 D[i][j]。

D[i][j-1] 为 A 的前 i 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们在 A 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i][j-1] + 1；

D[i-1][j] 为 A 的前 i - 1 个字符和 B 的前 j 个字符编辑距离的子问题。即对于 A 的第 i 个字符，我们在 B 的末尾添加了一个相同的字符，那么 D[i][j] 最小可以为 D[i-1][j] + 1；

D[i-1][j-1] 为 A 前 i - 1 个字符和 B 的前 j - 1 个字符编辑距离的子问题。即对于 B 的第 j 个字符，我们修改 A 的第 i 个字符使它们相同，那么 D[i][j] 最小可以为 D[i-1][j-1] + 1。特别地，如果 A 的第 i 个字符和 B 的第 j 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，D[i][j] 最小可以为 D[i-1][j-1]。

那么我们可以写出如下的状态转移方程：

若 A 和 B 的最后一个字母相同：

\begin{aligned} D[i][j] &= \min(D[i][j - 1] + 1, D[i - 1][j]+1, D[i - 1][j - 1])\\ &= 1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1] - 1) \end{aligned}
D[i][j]
​	
  
=min(D[i][j−1]+1,D[i−1][j]+1,D[i−1][j−1])
=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1)
​	
 

若 A 和 B 的最后一个字母不同：

D[i][j] = 1 + \min(D[i][j - 1], D[i - 1][j], D[i - 1][j - 1])
D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1])

所以每一步结果都将基于上一步的计算结果

转载于：https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/

leetcode 198 213 打家劫舍

两个版本的打家劫舍，一种是房子呈直线排布，一种是房子呈圆形排布，规则都是不能偷相邻两家的东西

状态转移都一样，以当前房子有没有被偷分类，取最大值max(dp[i-1],dp[i-2]+s[i])

对于圆形排布的，如果用if-else判断第一间和最后一间偷不偷的关系就变复杂了，可以直接分两种情况；s[0:n-1]与s[1:n]

leetcode 516 最长回文子序列
---

子序列与子串不同的地方在于，子串是相邻的元素，而子序列中的元素不一定相邻，只要前后顺序与原始序列一致即可，这就导致最长回文子串的长度要通过一个变量不断记录并更新，而最长回文子序列长度只用看最后的一个记录值即可。

dp[i][j]=dp[i+1][j-1]+1 if s[i]=s[j] else dp[i][j]=dp[i+1][j-1] 注：dp[i][j]表示原始序列中s[i]到s[j]的序列中回文子序列的长度

计算采用逆序，从s[n]开始倒着计算知道s[0]这样才会使得所用到的dp[i+1][j-1]都计算出来

leetcode 674 最长连续递增序列
---

这道题很简单，只要判断当前值是否比上一步的值大从而决定是dp[i]+1还是dp[i]=1


