位运算
===

201. 数字范围按位与
---

给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

思路：相当于求m到n的公共前缀，但是有一个规律要注意，就是m到n这n-m+1个数字的公共前缀与m和n这两个数字的公共前缀相同。这个就要具体分析一下。
假设对于所有这些二进制串，前 i 位均相同，第 i+1 位开始不同，由于 [m,n] 连续，所以第 i+1 位在 [m,n] 的数字范围从小到大列举出来一定是前面全部是 0，
后面全部是 11，[9,12]的第三位中[9,11] 均为 0，[12,12] 均为 1。并且一定存在连续的两个数 x 和 x+1，满足 x 的第 i+1 位为 0，后面全为 1，x+1 的第 i+1 位为 1，
后面全为 0，因此第 i+1 位开始的剩余位均为 0，前 i 位由于均相同，因此按位与结果不变。最后的答案即为二进制字符串的公共前缀再用零补上后面的剩余位。
所有这些二进制字符串的公共前缀也即指定范围的起始和结束数字 m 和 n 的公共前缀。

方案一：位移

将两个数字不断向右移动，直到数字相等，即数字被缩减为它们的公共前缀。然后，通过将公共前缀向左移动，将零添加到公共前缀的右边以获得最终结果。

 while m < n:
 
            m = m >> 1
            
            n = n >> 1
            
            shift += 1
            
        return m << shift

方案二：

Brian Kernighan 算法，它用于清除二进制串中最右边的 1。

while m < n:

            # 抹去最右边的 1
            
            n = n & (n - 1)
            
        return n




