datawhale八月小组学习开始啦~TASK1 分治算法
===

分治算法顾名思义，分而治之，将一个问题划分为一个个模式相同的小问题，通过一个个小问题的解决从而达到解决问题的效果，分治算法中常常会用到递归算法，比较典型的如leetcode中50、53、169。<br>

leetcode 50 pow(x,n)
---
计算x的n次幂<br>
暴力算法就是计算n-1次乘法，但是这无意中浪费了很多算力。例如pow(x,9)=x*x*x*x*x*x*x*x*x=x->x^2->x^4->x^8->x^9,将pow(x,n)看做pow(x,[n/2])的平方，此时就要判断一下n的奇偶性，奇数时就要在pow(x,[n/2])的平方的基础上再多乘一个x，此时就可以利用递归，一直递归到pow(x,1)=x，再往回算，即可算出pow(x,n)<br>
优化方法：<br>
由pow(x,n)的n的二进制形式可以发现，9=1001，x^9=x^8*x,此时不必讨论n的奇偶性，仅仅根据n的二进制形式中哪些位为1，哪些位就乘相应的x的幂，否则则将x的幂平方，并不直接乘到结果里。

leetcode 53 最大子序和
---
最直接的想法就是动态规划方法（虽然一开始我都没注意到这居然是动态规划），利用历史子序和与当前值做判断，看看是把当前值加入到子序中还是当前值是一个新的开始<br>
分治算法就是将整个序列分为左右两个部分，最大子序和就变为了左边部分的最大子序和、右边部分最大子序和、横跨中间分割点（从左到右的子序列和从右到左的子序列）这四个序列中的最大值，利用递归算法进行计算<br>

leetcode169 求众数
---
题目中明确说明了众数的个数大于[n/2],那么原数列中的众数肯定也是左子序列或右子序列的众数，求出左子序列的众数及右子序列的众数，然后比较一下这两个数在原始数列中出现的频次即可<br>
其实python中有一个专门统计数列中各元素出现次数的函数：collections.Counter，直接调用即可，两句话的事情<br>
