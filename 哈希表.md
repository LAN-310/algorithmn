哈希表
===

哈希表是一种数据结构～

基本概念
哈希表可以存储各种类型的数据，当我们从哈希表中查找所需要的数据时，理想情况是不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使每个关键字和结构中一个唯一的存储位置相对应。(关键字就是所要存储的数据，存储位置相当于数组的索引)

当然，可以把哈希表理解为一个数组，每个索引对应一个存储位置，哈希表的索引并不像普通数组的索引那样，从0到length-1，而是由关键字(数据本身)通过哈希函数得到

eg1. 将26个小写字母存储到数组  int [26] a。

a对应a[0]，b对应a[1]，c对应a[3]……以此类推。

图片发自简书App

那么，数组 int [26] a 就是一个哈希表！

哈希函数
例1中，关键字(小写字母)是如何得到自己对应的索引(存储位置)的呢？

关键字的ASCII值减去a的ASCII值！

图片发自简书App
上面说过，关键字通过哈希函数得到索引，所以，f(ch)就是本例题的哈希函数。

这样，我们就在关键字和数字(存储位置)之间建立了一个确定的对应关系f。

关键字与数字是一一对应的，由于数组本身支持随机访问，所以，当查找关键字时，只需要O(1)的查找操作，也就是实现了不经过任何比较，一次便能得到所查记录。

哈希表中哈希函数的设计是相当重要的，这也是建哈希表过程中的关键问题之一。

哈希冲突
假如，我们所要存储的数据其关键字是一个人的身份证号(18位数字)，这个时候我们该怎么计算关键字对应的索引呢？

比如一个人的身份证号是 411697199702076425，我们很难像例1那样直接让关键字与数字建立一一对应的关系，并且保证数字适合作为数组的索引。

在这种情况下，通过哈希函数计算出的索引，即使关键字不同，索引也会有可能相同。这就是哈希冲突

当索引相同时，我们该怎么存储数据呢？如何解决哈希冲突，是我们建哈希表的另一个关键问题。

空间换时间
哈希表充分体现了空间换时间这种经典的算法思想。

关键字是大整数时，比如上面我们举的身份证号例子，411697199702076425

假如我们能开辟一个 999999999999999999 大的空间，这样就能直接把身份证号作为关键字存储到数组中，这样可以用O(1)时间完成各项操作

假如我们只有 1 的空间，我们需要把所有信息存储到这个空间中(也就是所有数据都会产生哈希冲突)，我们只能用O(n)时间完成各项操作

事实上，我们不可能开辟一个如此大的空间，也不可会开辟如此小的空间

无限空间时，时间为O(1)

1的空间时，时间为O(n)

而哈希表就是在二者之间产生一个平衡，即空间和时间的平衡。

哈希表中的关键问题
1.哈希函数的设计

2.解决哈希冲突

3.哈希表实现时间和空间的平衡

上一篇文章中，我们举了身份证号为关键字的例子。这里，我们假设真的有一个无限大的空间，那么，可以直接将身份证号作为索引吗？

显然不合适。因为，并不是所有的身份证号都是18位的，对于那些位数在17位以下的，就太浪费这个大空间了。

设计哈希函数的原则是，将我们所关心的键通过哈希函数求出索引，“键”通过哈希函数得到的“索引”分布越均匀越好(实际上，实现起来非常困难)

那么，对于像身份证号这样的大整数为关键字时，该怎么计算对应的索引呢？

或者像复合类、字符串、浮点数这样类型的关键字，该如何计算它们对应的索引呢？

对于哈希函数来说，我们只能将整型数据作为关键字来求解索引。所以，不管什么类型的关键字，我们应该先将其转化为整型类型的数据。

按照这个思路，以下介绍几种最简单、最基础、最一般、最通用的哈希函数

整型
小范围正整数直接使用

例如，上一篇讲的ASCII值作为关键字

再例如，一个班有30个学生，1—30表示每位学生对应的学号，并作为关键字

像这样的小范围正整数，可以直接将关键字作为索引，存储到数组中去

小范围负整数进行偏移

例如，-100～100的数作为关键字，这时可以每个数都加上100，变为0～200的正整数

这样，就可以将关键字直接作为索引存储到数组中去

大整数取模

例如，身份证号作为关键字，412637199707096354

取后四位(6354)。也就是，mod 10000

假如，取后六位(096354)。即，mod 100 0000 这样，会分布不均匀

对于身份证号来说，后六位的前两位(09)代表着日期数，也就是1～31的数字。那么，这个六位数不会达到32 0000这么大，中国这么多人口，显然这个数字是不够的，这也就造成了索引分布不均匀

这也就体现了哈希函数的复杂性，也说明了具体问题要具体分析。

上面的取模方式还有一个问题，没有有效利用所有信息。我们这样取模，只是利用了关键字的一部分，也就是不管这个人是哪个地区哪个年份出生的，都有可能存储到一个地址中去，这样会增加哈希冲突的概率。那么，该如何解决这个问题呢？

一个简单的解决办法：模一个素数

为什么要模一个素数呢？简单举个例子

图片发自简书App
显然，模一个素数，结果会分布的更均匀，哈希冲突的概率也会变小。我们该如何选择这个素数呢？相关的领域专家已经为我们研究出了答案。

图片发自简书App
假如，需要存储的数在2^5～2^6之间，模上53就可以了。

注：这个表并不是唯一的，一个区间内可以有多个素数

浮点型
将浮点型解析成大整型，之后再相应取模(如上)

字符串
先看一个例子

图片发自简书App
把一个整数用科学计数法来表示，同样，字符串也可以类似表示。将这个字符串看成26进制，是因为有26个小写字母，如果字符串中有大写字母或者标点符号，那么看成26进制显然是不够的，可以看成是100进制或者256进制等。显然，这个进制是用户可以自己选择的，我们用 B 来表示这个进制

图片发自简书App


每一个小写字母对应一个数字，这样我们把字符串也转化成了大整型，之后就可以利用上面取模的方式计算哈希值了。

字符串哈希函数
这样就可以计算出字符串的哈希值了。当B是一个比较大的数或者字符串比较长时，求B的k次方是比较浪费时间的，所以我们可以优化这个表达式

哈希函数*优化
这样就省去了求次方运算。但是，还有可能会出现整型溢出的情况，当B是一个很大的数字或者字符串很长的时候，我们可以再次优化这个表达式

哈希函数*再次优化
这样，每退出一个小括号，数字都会变成比M先得数字，就不会出现溢出情况了

复合类
假如我们自己定义一个类，日期类

Date：year，month，day

为这个Date类设计哈希函数，可以像字符串那样，将类的属性值看着是一个字符

复合类哈希函数
这样，就求出了复合类的哈希值。

求哈希函数原则
原则
一致性：当关键字相同时，经过哈希函数求出的哈希值也是相同的。

反过来是不成立的，即当哈希值相同时关键字不一定相同。哈希值相同，取模后得到的索引也相同，即不同的关键字对应的存储位置相同，这也就是所谓的哈希冲突。

高效性：我们设计哈希函数就是为了高效存储数据，如果哈希函数的设计就消耗过多性能，那么就得不偿失了

均匀性：通过哈希函数求出的索引必须是分布均匀的。



作者：尤奇勤_三月
链接：https://www.jianshu.com/p/cccbf80e2629
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：尤奇勤_三月
链接：https://www.jianshu.com/p/4e64fce04a38
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：invalid s
链接：https://www.zhihu.com/question/330112288/answer/744362539
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

很多人谈起“哈希表”，就会直接聚焦到hash函数、“散列”/“杂凑”之类不明所以的大词上，搞的初学者一头雾水，完全不明白这东西是干嘛用的，更不知道什么时候该用它、怎么用它、出现问题如何解决。那么，这里我就从问题开始，一步步把哈希表的来龙去脉剖析清楚。想象一下：有一天，你开车到某商场去买东西。买完东西，你想不起自己的车在哪了。这家商场非常非常大，楼下停车场少说停了上万台车；而你的健忘症又比较厉害……那么，问题来了：你怎样才能找到自己的车？一个理想的情形是，你从头到尾一行一行一辆一辆按顺序走一遍就找到了；运气最差时，你搜遍楼下N辆车，发现你的车在末尾——拿术语说，这个复杂度是O(N)。能不能更快一些呢？很简单，假如所有车按车牌号顺序排列，你直接往停车场中间走就行了；如果你的车牌号大于中间那辆车，那么你就往停车场后半部分的中间走，否则就往前半场走……依此类推。如此一来，你最多只需要走ln（N）次“中间”，就能找到你的车了。黑话叫复杂度O(ln N)。还能不能更给力一些？可以。假设这个停车场非常非常大，大到可以给每个车牌号分配一个固定的停车位；那么只要你把自己的车牌号报给看门老头，他拎着你的衣领子往后一丢，你就“吧唧”一下掉自己车顶上了——嗯，你看，一车一位，就是这么任性。这就叫“查找复杂度O(1)”。如果用程序实现的话，就是这么一个数组：car park[MAX_CAR_NUM]第一个场景，你要直接以一个循环遍历park中的每个元素。第二个场景，你只需先访问MAX_CAR_NUM除以2的那个位置，再根据车牌号大小访问数组前半拉或者后半拉中间的元素即可。第三个场景，你的车牌号就是数组下标，所以你只需直接访问park[CAR_NUMBER]即可。那么，第三个设计是不是完全解决问题了呢？并不是。很容易看出，第三个方案需要一个超级大的存储空间。这个空间得有多大呢？它必须大到足以和过去未来的一切有效车牌号一一对应，你才可能做到“直接按号访问”。假设车牌号共8位，每位可以使用26个英文字母或10个阿拉伯数字，那么不同的车牌号共有36^8=2821109907456种。哪怕每辆车只需一个字节的存储空间，这也是接近3T的空间！而事实上，哪怕最大的超市，修一个够停一万辆车的停车场也都太夸张了。你看，这完全行不通啊。那么，有没有办法在得到O(1)的查找效率的同时、又不付出太大的空间代价呢？没错，的确是有的。这就是哈希表。哈希表是怎么玩的呢？很简单，我们把你的车牌号看作一个8位36进制的数字；为了方便，我们可以把它转换成十进制。那么，你的车牌号就是一个不大于2821109907456的数字。现在，我们把你的车牌号除以一万，只取余数——你看，你的车牌号是不是就和0~10000之间的数字对应起来了？很好，你的车就停在这个数字对应的停车位上，过去开就是了——O(1)的查找效率！这个“把你的车牌号映射进0~10000之间”的操作，就是所谓的“散列”“杂凑”“哈希”或者hash（当然，实践上，为了尽量减少冲突，哈希表的空间大小会尽量取质数）。相对于“以key为下标直接访问的数组”，哈希表是“时间换空间”；相对于二分法查找，哈希表又是“以空间换时间”。这种“中庸”的定位使得它在许多场合极为好用。等等，你发觉不对：我的车尾号456，我朋友的车也是这个尾号。我们总不能停在同一个位置吧？你这个方案有瑕疵啊！没错，hash可能会把不同的数据映射到同一个点上，术语称其为“碰撞”。由于hash自身的基本原理，碰撞是不可避免的。怎么解决这个“碰撞”问题呢？几种解决思路：1、临时加个“立体车库”，哪里碰撞往哪放。于是车子就可以在同一位置“撂起来”存了。这叫“开链表法”。2、车库面积肯定是够的。456号被人占了，你存457不就好了！换句话说，过去的散列函数是 （车牌号 模除 10000），发现碰撞了就换散列函数 （车牌号加1 模除 10000）试一试——这叫“再散列法”。3、再修个小车库，碰撞了的停小车库去（小车库可以随便停，也可以搞一套别的机制）总之，如此一来，我们就同时得到了“O（1）的查找效率”和“可接受的空间消耗”。任何时候，当你有“数量有限”但“不同索引数量极大”的一些数据，必需极高的访问效率同时又不想无端消耗太多的存储空间时，你就可以考虑使用哈希表了。当然，请注意，因为冲突的存在，哈希表虽然有着优异的平均访问时间（常数访问效率！）；但它的“最大访问时间”却是没有保证的——你可能一个微秒甚至几个纳秒就拿到了数据，也可能几十个毫秒了还在链表上狂奔。因此实时性要求严格的场合，用它前需要谨慎考虑。知道了哈希表的设计思路，我们就可以进入稍微困难一些的部分了。我们已经知道，所谓“哈希表”，实际上是我们把对象（value）的“键值（key)”转换成了“数组下标”；然后就可以借助这个下标一步到位的找到对应对象（value）了。但这中间有“瑕疵”存在：和身份证号和公民一一对应不同，键值和下标并不是一对一的关系。就好像你的车牌尾号是3456而你朋友是5456，结果把你们安排到同一个停车位一样。很容易想到，很多数据的键值（key）分布存在一定的规律。比如，男性身份证最后一位总是单数；你们班所有同学几乎都在97~99年之间出生，等等。那么，如果我们的“键值转换数组下标的函数（也就是哈希函数）”选择不当（比如我前面提到的直接求余），就很容易使得“碰撞”频繁出现。这就对哈希函数的选择提出了要求。但是哈希函数本身也不应该过于复杂，不然每次计算耗时太久——O(1)虽然是常数时间；但如果时间常数太长，它可能就不如O（lnN）查找算法快。要知道，在一百万数据里面做二分法搜索，最差时也不过需要20次搜索而已；如果你的哈希函数本身需要的计算时间已经超过了这个限度，那么改用二分法显然是个更为理智的选择：不仅更快，还更省空间。工程问题，向来是需要根据实际情况灵活选择、做出合理折衷的。扯远了。继续说哈希函数。很显然，用于哈希表的哈希函数可不能是MD5或者sha1系列函数，太慢；但也不能直接模除一个整数，太容易出现冲突。简单说就是：哈希表用到的哈希函数，一方面要能尽量把key均匀散布在表空间中（从而尽量减少冲突），另一方面又要有尽量快的计算速度。这类函数有很多种，稍微搜一搜就能找到很多。不过，无论如何，哈希表中，碰撞无法绝对避免。当碰撞发生时，就不得不使用开链表法或再散列法存储冲突数据；而这必将影响哈希表的性能。当哈希函数选择合适时，想要减少碰撞，就只能扩大哈希表占用的空间。很容易想到，如果哈希表很大、里面却没存几条数据，那么它出现冲突（碰撞）的几率就会很小；反之，如果哈希表已经接近满了，那么每条新加入的数据都会产生碰撞。哈希表实际所存数据量和哈希表最大容量之间的比值，叫做哈希表的“加载因子”。加载因子越小，冲突的概率就越低，但浪费大量空间；加载因子越高，冲突概率越大，但空间浪费就越少。这是一个需要根据工程实践灵活选择的折衷值。很多语言的hash函数库允许你主动调节这个值。一般来说，一个较为平衡的加载因子大约是0.7~0.8左右。这样既不会浪费太多空间，也不至于出现太多冲突。另一方面，因为哈希表使用的哈希函数较为简单，因此对恶意的攻击者来说，他可以精心构造一大堆数据提交给你——所有这些数据散列后全都存在一个格子里。我们前面提到过，当遇到这种冲突/碰撞时，为了避免彼此覆盖，这些数据就要存在链表中（或者再散列后存在同一个哈希表中）。当这些数据被存进链表时，对它们的访问效率将降到O(N)——因为链表搜索效率只有O(N)。之前就发生过这种攻击，包括Java在内的许多种语言全部落马。解决方案也很简单：1、提高哈希函数复杂度，想办法加入随机性（相当于每次使用一个不同的哈希函数），避免被人轻易捕捉到弱点2、不要用开链表法存储冲突数据，采用“再散列法”，并且使用不同的哈希函数再散列、还可以把冲突数据存入另一个表——要构造同时让两个以上不同的哈希函数冲突的攻击数据，难度就大得多了。总之，哈希表是用途广泛的一种数据结构，也是很多编程语言提供的基础服务之一（比如python的dict）。
