
查找1
===

查找1中所涉及到的题目主要分为二分查找以及利用哈希表映射关系来查找。

leetcode 35
---

搜索插入位置:给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

这个问题显然要用二分查找，一般二分法的时间复杂度为O（logn）

leetcode 202 快乐数
---

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

首先分析数字平方和的变化趋势情况：

（1）最终变为1

（2）陷入某个循环中

（3）不可能无穷大发散掉，对于大于999的数字，平方和得到的结果都是比原值小的，最终数字都会慢慢小于999，平方和也就在243内

对于（2）中有个环，所以要检测一下当前值是否在之前结果中出现过，如果出现过就陷入了环中，对于这种类型的查找，哈希表比较适合，利用哈希表记录key出现的次数即可。而由于次数只要大于1就false，所以可以利用hashset来记录出现过的值就好，然后判断一下新算出来的值有没有在集合里面，有的话说明陷入环中了。

leetcode 205 同构字符串
---

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

示例 1:

输入: s = "egg", t = "add"
输出: true

思路：利用hashmap建立s到t的映射，如果有新的映射关系，判断该映射关系是否与旧关系冲突，不冲突就加到hashmap中，冲突就返回false.

这里需要注意的一点就是需要再建立t到s的映射检验一遍，可能e-a,g-a 则egg-aaa，s到t是符合的但是t到s不符合

leetcode 290 单词规律
---

给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

示例1:

输入: pattern = "abba", str = "dog cat cat dog"
输出: true

思路：与205思路相同，要正反映射都判断一遍，或者另外一种办法，都映射到一组数字中，判断两组数字是否相等。abba-1221  dog cat cat dog-1221

leetcode 242 有效的字母异位词
---
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true

利用hash表判断key及value是否对应相等

优化：上述思路需要开两个hash表，占用空间，可以出现t中的一个元素就在s中相应元素中的value基础上减一，最后判断看看有没有value是负值或者正值

leetcode 349 两个数组的交集
---

给定两个数组，编写一个函数来计算它们的交集。

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

思路：由于输出的只有交集中的元素种类，不管元素出现次数，所以利用长度小的数组建立hashset，然后判断另一较长数组中的数字是否在set中，在的话就保存下来。

leetcode 350 两个数组的交集II
---

给定两个数组，编写一个函数来计算它们的交集。

 

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

思路：与上一题的区别在于输出中考虑了元素出现的次数，这是改用hash表来统计两个数组中各元素出现的次数，每种出现次数不为0的元素选两个次数中最小的一个，最后根据统计的次数输出每种元素

leetcode 410 
---

给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

注意:
数组长度 n 满足以下条件:

1 ≤ n ≤ 1000
1 ≤ m ≤ min(50, n)

思路：二分查找+贪心

「使……最大值尽可能小」是二分搜索题目常见的问法。

本题中，我们注意到：当我们选定一个值 xx，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 xx。策略如下：

贪心地模拟分割的过程，从前到后遍历数组，用 \textit{sum}sum 表示当前分割子数组的和，\textit{cnt}cnt 表示已经分割出的子数组的数量（包括当前子数组），那么每当 \textit{sum}sum 加上当前值超过了 xx，我们就把当前取的值作为新的一段分割子数组的开头，并将 \textit{cnt}cnt 加 11。遍历结束后验证是否 \textit{cnt}cnt 不超过 mm。

这样我们可以用二分查找来解决。二分的上界为数组 \textit{nums}nums 中所有元素的和，下界为数组 \textit{nums}nums 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和，这样就可以得到最终的答案了。

leetcode 540
---

给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

示例 1:

输入: [1,1,2,3,3,4,4,8,8]
输出: 2

思路：二分查找，更新mid有一定技巧，每次去掉中间的两个相同的数字，剩下的两组数组中长度为奇数的含目标值

leetcode451
---

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

示例 1:

输入:
"tree"

输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。

思路：hash表统计









