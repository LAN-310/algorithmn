做过一些公司的笔试，大多笔试中都有关于路径搜索的题目，要么是一个有向图或者无向图，要么是一个矩阵，在矩阵中不碰到障碍物的情况下可以上下左右四个方向走。对于这种题目一般就是深搜或者广搜了。

例1，leetcode 797 所有可能的路径
典型的深搜的题目，深搜题目一般都是和递归结合起来的
def dfs(x,y):
  global ...
  if 越界 or 遇到障碍物：
    return  
  board[x][y]=障碍
  for dx,dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]:
    dfs(i+dx,j+dy)  
  board[x][y]=原值(如果不是路径搜索，而是求满足某种条件的区域的个数及大小，则不必还原为原值，如leetcode 130、leetcode 面试题16.19)
  
  
  
  广搜一般用于求最短路径问题，当然求最短路还有很多方法，比如dijkstra，但是私以为，广搜是其中最简单并且代码量最小的方法。
  不管是广搜还是digkstra方法，都需要用到用到队列这种数据结构，Dijkstra 算法适合用来求出无负权边图中的单源最短路径。其中「无负权边」表示图中所有边的权值必须为非负数，「单源最短路径」表示 Dijkstra 算法可以求出从某一个节点到其余所有节点的最短路径

例 leetcode 1368
0-1 bfs:
def bfs0_1:
  dis=[0]+[1e9]*...初始化距离矩阵或数组，令所有值为inf,当然起点值为0
  seen=set()
  q=collections.deque()
  q.append([起点])
  while (len(q)):
    #先取出队首元素
    x,y=q.popleft()
    #判断是否走过（x,y)
    if (x,y) in seen:
      continue
    #如果没走过则进行下面的步骤
    #（1）先把这个点加入到seen中
    seen.add((x,y))
    (2)判断新的节点的距离和dis[该节点]的大小，若更小，则进行下面的步骤：
    
    
  
  
 
